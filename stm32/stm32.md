[TOC]

### 1、stm32

#### 1.1、stm32简介

>•STM32是ST公司基于ARM Cortex-M内核开发的32位微控制器
>
>•STM32常应用在嵌入式领域，如智能车、无人机、机器人、无线通信、物联网、工业控制、娱乐电子产品等
>
>•STM32功能强大、性能优异、片上资源丰富、功耗低，是一款经典的嵌入式微控制器

![](img/stm32简介.png)

#### 1.2、ARM

>•ARM既指ARM公司，也指ARM处理器内核
>
>•ARM公司是全球领先的半导体知识产权（IP）提供商，全世界超过95%的智能手机和平板电脑都采用ARM架构
>
>•ARM公司设计ARM内核，半导体厂商完善内核周边电路并生产芯片

![](img/ARM1.png)

![ARM2](img/ARM2.png)

#### 1.3、STM32F103C8T6

![](img/STM32F103C8T6.png)

![stm32简介](img/stm32简介.png)

#### 1.4、命名规则

![](img/命名规则.png)

#### 1.5、系统结构

![](img/系统结构.png)

#### 1.6、引脚定义

![](img/STM32F103C8T6引脚定义.png)

![引脚定义](img/引脚定义.png)

[引脚定义](STM32F103C8T6引脚定义.xlsx)

#### 1.7、启动配置

![](img/启动配置.png)

#### 1.8、最小系统电路

![](img/最小系统电路.png)

### 2、keil新建stm32工程

[keil5_MDK安装教程](https://www.bilibili.com/video/BV1th411z7sn/?spm_id_from=333.1391.0.0&p=3&vd_source=5f8610a33e469a605635adbbdcc8c98e)

> 开发方式:
>
> - 基于寄存器的方式——类似51，程序直接配置寄存器
> - 基于标志库的方式（库函数）——使用ST官方封装好的库函数间接配置寄存器
> - 基于HAL方式——用图形化界面快速配置stm32

#### 2.1、新建Strat文件

>启动文件(官方下载的文件)
>
>STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\startup\arm

![](img/启动配置文件.png)

>| **缩写**  (文件后缀) | **释义**           | **Flash容量** | **型号**          |
>| -------------------- | ------------------ | ------------- | ----------------- |
>| LD_VL                | 小容量产品超值系列 | 16~32K        | STM32F100         |
>| MD_VL                | 中容量产品超值系列 | 64~128K       | STM32F100         |
>| HD_VL                | 大容量产品超值系列 | 256~512K      | STM32F100         |
>| LD                   | 小容量产品         | 16~32K        | STM32F101/102/103 |
>| MD                   | 中容量产品         | 64~128K       | STM32F101/102/103 |
>| HD                   | 大容量产品         | 256~512K      | STM32F101/102/103 |
>| XL                   | 加大容量产品       | 大于512K      | STM32F101/102/103 |
>| CL                   | 互联型产品         | -             | STM32F105/107     |



>外设寄存器描述以及system配置文件
>
>STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x
>
>​	stm32f10x.h 外设描述文件，类似REGX51.h
>
>​	system开头的文件：配置时钟

![](img/头文件.png)

>内核寄存器描述
>
>STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\CMSIS\CM3\CoreSupport

![](img/内核寄存器描述.png)

将上述文件复制，并在自己的项目中创建Start文件夹，并且复制到里面。在keil5中添加文件夹与文件

![](img/添加Start路径.png)





>项目中Start文件中实际添加的文件
>
> 	钥匙符号代表只读

![](img/项目中Start添加文件.png)

>在项目中添加文件路径（让keil知道去哪里找）

![](img/添加Start路径.png)

#### 2.2、新建User文件

>1.在项目中新建User文件夹（用于存放main函数和自己的代码）
>
>2.在keil5中创建组，并改名为User
>
>3.添加main函数
>
>4.创建main函数（注意：将路径改到User目录下）

![](img/User创建注意事项1.png)





>调字体、调缩进、调编码格式

![](img/调编码.png)

![调字体](img/调字体.png)

#### 2.3、配置调试器

![](img/调试器.png)

![调试器正常识别](img/调试器识别正常.png)

![](img/烧录程序.png)

> 下载到实物上后（蓝色LED灯不在闪烁—闪烁原因：stm32内置的调试程序）





>以上的创建完，就可以用基于寄存器的开发方式写stm32了。

![](img/寄存器开发例子.png)

#### 2.4、新建Library文件

>1.在项目中新建Library文件夹
>
>2.在STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\STM32F10x_StdPeriph_Driver\src与STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\STM32F10x_StdPeriph_Driver\inc中复制库函数源文件和头文件，复制到Library中

![](img/Library中文件.png)

>3.在keil5的项目中新建Library组，并且添加上面的所有文件

![](img/Library中文件2.png)

#### 2.5、在User文件夹中新增文件

>在STM32F10x_StdPeriph_Lib_V3.5.0\Project\STM32F10x_StdPeriph_Template复制一下文件，复制到项目User目录下
>
>​		conf用于配置u库函数头文件的包含关系

![](img/User新增.png)

>在keil5的项目User文件下新增，并且设置宏定义（USE_STDPERIPH_DRIVER在stm32f10x.h文件的最后面）

![](img/User新增1.png)





>以上为库函数开发方式

![](img/库函数开发方式.png)



==新建文件步凑==

>•建立工程文件夹，Keil中新建工程，选择型号
>
>•工程文件夹里建立Start、Library、User等文件夹，复制固件库里面的文件到工程文件夹
>
>•工程里对应建立Start、Library、User等同名称的分组，然后将文件夹内的文件添加到工程分组里
>
>•工程选项，C/C++，Include Paths内声明所有包含头文件的文件夹
>
>•工程选项，C/C++，Define内定义USE_STDPERIPH_DRIVER
>
>•工程选项，Debug，下拉列表选择对应调试器，Settings，Flash Download里勾选Reset and Run



### 3、GPIO

#### 3.1、GPIO简介

>•GPIO（General Purpose Input Output）通用输入输出口
>
>•可配置为8种输入输出模式
>
>•引脚电平：0V~3.3V，部分引脚可容忍5V
>
>•输出模式下可控制端口输出高低电平，用以驱动LED、控制蜂鸣器、模拟通信协议输出时序等
>
>•输入模式下可读取端口的高低电平或电压，用于读取按键输入、外接模块电平信号输入、ADC电压采集、模拟通信协议接收数据等

#### 3.2、GPIO基本结构

>所有的GPIO都挂载在APB2总线上。
>
>GPIO中的寄存器为32位寄存器，P0~P15只是使用了低16位。
>
>驱动器负责增大驱动能力。

![](img/GPIO基本结构.png)

#### 3.3、GPIO位结构

![](img/GPIO位结构.png)

>输入部分：
>
>①：保护二极管：保护电路。当输入电压大于VDD时，上部分的二极管导通，电流流向VDD；当输入电压小于VSS时，下部分的二极管导通，电流从VSS流向I/O引脚。只有在VSS~VDD之间才能输入。I/O引脚电压相对于VSS，可以存在负数。
>
>②、③：上拉电阻、下拉电阻。当②打开，③关闭时，为上拉输入（默认为高电平输入）；当③打开，②关闭时，为下拉输入（默认为低电平输入）；当②、③都关闭时，为浮空输入（及其不稳定）。上拉电阻与下拉电阻阻值一般比较大，所以是弱上拉与弱下拉，目的是为了不影响正常输入操作。
>
>④、TTL施密特触发器（由肖特基管构成）。对输入电压进行整形。虽然输入电压为数字信号，但是也会存在波动。
>
>![](img/TTL施密特触发器.png)
>
>输出部分：
>
>⑤、位设置/位清除寄存器：用于操作输出数据寄存器（只能整体读写）的某位进行置1或者置0。
>
>​	常见的位操作：
>
>​		a、将输出数据寄存器读出，通过&=和|=操作，在整体写入到输出数据寄存器中。
>
>​		b、设置位设置/位清除寄存器，对位设置/位清除寄存器中的某位进行操作，然后整体写入输出数据寄存器。
>
>​		c、读写stm32位带区域（等价于51位寻址）。
>
>⑥、⑦：PMOS管（低电平导通）、NMOS管（高电平导通）。==推挽输出模式==（强推模式）下，PMOS管和NMOS管均有效，当输出数据寄存器输出1时，PMOS管导通，NMOS管断开，I/O引脚直接接到VDD，输出高电平；当输出数据寄存器输出0时，PMOS管断开，NMOS管导通，I/O引脚直接接到VSS，输出低电平，==高低电平均匀驱动能力==。==开漏输出模式==下，PMOS管无效，NMOS管有效，当输出数据寄存器输出1时，NMOS管断开，输出断开，相当于高祖模式；当输出数据寄存器输出0时，NMOS管导通，I/O引脚直接接到VSS，输出低电平；开漏模式下，==只有低电平有驱动能力==，常用于通信协议的驱动，如：I2C。

#### 3.4、GPIO输入输出模式

>| **模式名称**                       | **性质** | **特征**                                                     |
>| ---------------------------------- | -------- | ------------------------------------------------------------ |
>| 浮空输入 （GPIO_Mode_IN_FLOATING） | 数字输入 | 可读取引脚电平，若引脚悬空，则电平不确定 ,使用时，端口一定要接上连续驱动源 |
>| 上拉输入  （GPIO_Mode_IPU）        | 数字输入 | 可读取引脚电平，内部连接上拉电阻，悬空时默认高电平           |
>| 下拉输入  （GPIO_Mode_IPD）        | 数字输入 | 可读取引脚电平，内部连接下拉电阻，悬空时默认低电平           |
>| 模拟输入 （GPIO_Mode_AIN ）        | 模拟输入 | GPIO无效，引脚直接接入内部ADC                                |
>| 开漏输出  （GPIO_Mode_Out_OD）     | 数字输出 | 可输出引脚电平，高电平为高阻态，低电平接VSS                  |
>| 推挽输出  （GPIO_Mode_Out_PP）     | 数字输出 | 可输出引脚电平，高电平接VDD，低电平接VSS                     |
>| 复用开漏输出（GPIO_Mode_AF_OD）    | 数字输出 | 由片上外设控制，高电平为高阻态，低电平接VSS                  |
>| 复用推挽输出  （GPIO_Mode_AF_PP）  | 数字输出 | 由片上外设控制，高电平接VDD，低电平接VSS                     |

>浮空/上拉/下拉输入
>
>![](img/浮空、上拉、下拉输入模式.png)

>模拟输入
>
>![](img/模拟输入.png)

>开漏/推挽输出（也可以进行简单的输入）
>
>![](img/开漏、推挽输出.png)

>复用开漏/推挽输出
>
>![](img/复用开漏、复用推挽输出.png)

#### 3.5、传感器模块

##### （1）简介

>•传感器模块：传感器元件（光敏电阻/热敏电阻/红外接收管等）的电阻会随外界模拟量的变化而变化，通过与定值电阻分压即可得到模拟电压输出，再通过电压比较器进行二值化即可得到数字电压输出

![](img/传感器模块.png)

##### （2） 硬件电路

![](img/传感器硬件电路.png)

![](img/4引脚按键.png)

### 4、OLED调试

>调试方式	
>
>•串口调试：通过串口通信，将调试信息发送到电脑端，电脑使用串口助手显示调试信息
>
>•
>
>•显示屏调试：直接将显示屏连接到单片机，将调试信息打印在显示屏上
>
>•
>
>•Keil调试模式：借助Keil软件的调试模式，可使用单步运行、设置断点、查看寄存器及变量等功能

#### 4.1、简介

>•OLED（Organic Light Emitting Diode）：有机发光二极管
>
>•OLED显示屏：性能优异的新型显示屏，具有功耗低、相应速度快、宽视角、轻薄柔韧等特点
>
>•0.96寸OLED模块：小巧玲珑、占用接口少、简单易用，是电子设计中非常常见的显示屏模块
>
>•供电：3~5.5V，通信协议：I2C/SPI，分辨率：128*64
>
>

#### 4.2、硬件电路

![](img/OLED硬件电路.png)

>4引脚使用的是I2C协议，7引脚使用的是SPI引脚

### 5、keil调试方式

>选择进行仿真调试，并且连接好stm32

![](img/keil仿真调试1.png)

>点击编译，点击仿真按钮

![](img/keil仿真调试2.png)

>菜单介绍

![](img/keil仿真调试3.png)

![keil仿真调试4](img/keil仿真调试4.png)

![keil仿真调试5](img/keil仿真调试5.png)

>注意：==每次退出仿真调试，需要重新编译，在进入==









### C语言

>数据类型
>
>| **关键字**         | **位数** | **表示范围**                 | **stdint.h** **重定义关键字** | **ST** **关键字**（老版本） |
>| ------------------ | -------- | ---------------------------- | ----------------------------- | --------------------------- |
>| char               | 8        | -128 ~ 127                   | int8_t                        | s8                          |
>| unsigned char      | 8        | 0 ~ 255                      | uint8_t                       | u8                          |
>| ==short==          | ==16==   | ==-32768 ~ 32767==           | ==int16_t==                   | ==s16==                     |
>| unsigned short     | 16       | 0 ~ 65535                    | uint16_t                      | u16                         |
>| ==int==            | ==32==   | ==-2147483648 ~ 2147483647== | ==int32_t==                   | s32                         |
>| unsigned int       | 32       | 0 ~ 4294967295               | uint32_t                      | u32                         |
>| ==long==           | ==32==   | ==-2147483648 ~ 2147483647== |                               |                             |
>| unsigned long      | 32       | 0 ~ 4294967295               |                               |                             |
>| long long          | 64       | -(2^64)/2 ~ (2^64)/2-1       | int64_t                       |                             |
>| unsigned long long | 64       | 0 ~ (2^64)-1                 | uint64_t                      |                             |
>| float              | 32       | -3.4e38 ~ 3.4e38             |                               |                             |
>| double             | 64       | -1.7e308 ~ 1.7e308           |                               |                             |



>C语言宏定义
>
>•关键字：#define
>
>•用途：用一个字符串代替一个数字，便于理解，防止出错；提取程序中经常出现的参数，便于快速修改（==定义一个常量或者常用数据==）
>
>•定义宏定义：
>
> \#define ABC 12345
>
>•引用宏定义：
>
> int a = ABC; //等效于int a = 12345;



>C语言typedef
>
>•关键字：typedef
>
>•用途：将一个比较长的==变量==类型名换个名字，便于使用
>
>•定义typedef：
>
> typedef unsigned char uint8_t;
>
>•引用typedef：
>
>  uint8_t a; //等效于unsigned char a;



>C语言结构体
>
>•关键字：struct
>
>•用途：数据打包，不同类型变量的集合
>
>•定义结构体变量：
>
> struct{char x; int y; float z;} StructName;  				（匿名结构体）
>
>
>
>struct aaa {char x; int y; float z;} ;		
>
>struct aaa pStructName;
>
>或者
>
>typedef struct {char x; int y; float z;}  aaa；		（加typedef换名）
>
>aaa pStructName;
>
>\> StructName,pStructName为结构体变量   aaa 为结构体类型名 <
>
> ==因为结构体变量类型较长，所以通常用typedef更改变量类型名==
>
>•引用结构体成员：
>
> StructName.x = 'A';
>
> StructName.y = 66;
>
> StructName.z = 1.23;
>
>或 pStructName->x = 'A'; //pStructName为结构体的地址 （结构体指针）
>
>pStructName->y = 66;
>
> pStructName->z = 1.23;



>C语言枚举
>
>•关键字：enum
>
>•用途：定义一个取值受限制的整型变量，用于限制变量取值范围；宏定义的集合
>
>•定义枚举变量：
>
> enum{FALSE = 0, TRUE = 1} EnumName;
>
>或者
>
>typedef  enum{FALSE = 0, TRUE = 1} aaa;
>
>aaa EnumName;
>
> ==因为枚举变量类型较长，所以通常用typedef更改变量类型名==
>
>•引用枚举成员：
>
> EnumName = FALSE;
>
> EnumName = TRUE;
>
>>枚举类型多文件抛出
>>
>>xxxx.h
>>
>>```c
>>#ifndef __XXXX_h_
>>#define __XXXX_h_
>>
>>typedef enum {
>>	ON = 0, 
>>	OFF = !ON
>>} xxx;
>>
>>#endif
>>
>>```
>>
>>main.c
>>
>>```c
>>#include <stido.h>
>>#include "xxxx.h"
>>
>>int main(){
>>    printf ("%d\n"，ON);
>>    return 0;
>>}
>>```
>>
>>



### 注意：

1、keil中CMSIS为红色，是因为支持包与MDK的版本不相符合。

2、写main函数时，必须位int main(){while(1){}} 切main函数写完还有空一行，否则会出现两个警告。

3、System文件夹用于存放自定义函数（系统资源）、功能函数。

4、Hardware文件夹用于存放硬件驱动。

5、ctrl+alt+空格 可以在没有代码提示的时候出现代码提示。
